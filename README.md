# CS-300
_**What was the problem you were solving in the projects for this course?**_ 

The main problem I was solving was dealing with the various data structures (hash tables, vectors, Binary Search Trees) and choosing the appropriate ones for the needed applications.  

_**How did you approach the problem? Consider why data structures are important to understand.**_ 

I attempted to weigh the strengths and weaknesses of each respective data structure in conjunction with the required uses for the assignments. From there I assessed which best fit the situation and where the benefits outweighed the drawbacks.  

_**How did you overcome any roadblocks you encountered while going through the activities or project?**_ 

Repeated testing helped me overcome roadblocks. I was able to determine the kinds of things I was doing wrong and from there I could tell what I needed to improve. I tried to research any official websites regarding the best standard practices and watched videos to further explain topics I was not grasping well. I tried to find examples of similar problems and tried to integrate the logic behind those problems into my work.  

_**How has your work on this project expanded your approach to designing software and developing programs?**_ 

I’ve added more criteria to my approach. I’ve found that I have a broader idea of things to consider when designing software. For example, after dabbling with the Big-O notation I’ve become more aware of performance aspects of design. I’ve become more considerate of the most efficient ways to accomplish a goal. 

_**How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?**_ 

I have become more aware of modular code design, where in the past I would create code to solve a specific problem that has been presented, which leads to issues with debugging, updating, and maintenance in the future. I’ve reinforced the idea of including comments throughout my work to increase readability as I’ve had issues in the past where I have no longer have any idea what my code pertains to. There are concepts and elements that I can reuse in the future and creating reusable code allows me to carry it over to future projects.  
